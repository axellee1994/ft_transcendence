# Backend Implementation Documentation for 42 Transcendence
# =====================================================

Table of Contents:
1. Backend Architecture Overview
2. Core Components Explanation
3. API Routes Implementation
4. Frontend-Backend Integration
5. Key Features and Benefits
6. Database Schema
7. Testing and Maintenance

# 1. Backend Architecture Overview

## Core Technologies
1. Fastify
   - Modern, fast web framework for Node.js
   - Designed with performance in mind
   - Plugin-based architecture

2. Node.js
   - JavaScript runtime environment
   - Event-driven, non-blocking I/O
   - Large ecosystem of packages

3. SQLite
   - Lightweight, file-based database system
   - Self-contained, serverless
   - ACID compliant

## Directory Structure (Backend)
```
backend/
├── srcs/
│   ├── server.js           # Main server entry point
│   ├── plugins/
│   │   └── db.js          # Database connection and setup
│   ├── routes/
│   │   ├── api.js         # API route registration
│   │   ├── users.js       # User-related endpoints
│   │   ├── games.js       # Game-related endpoints
│   │   └── tournaments.js # Tournament-related endpoints
│   └── data/
│       └── transcendence.db # SQLite database file
```

# 2. Core Components Explanation

## A. Server Setup (server.js)
```javascript
const fastify = require('fastify')({
  logger: {
    level: 'info',
    transport: {
      target: 'pino-pretty'
    }
  }
});

// CORS configuration for frontend communication
fastify.register(require('@fastify/cors'), {
  origin: '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
});

// Register plugins and routes
async function registerPlugins() {
  await fastify.register(require('./plugins/db'));
}

async function registerRoutes() {
  await fastify.register(require('./routes/api'), { prefix: '/api' });
}
```

This file:
- Creates the Fastify server instance
- Configures logging for debugging and monitoring
- Sets up CORS to allow frontend communication
- Registers database plugin and routes

## B. Database Setup (plugins/db.js)
```javascript
const fastifyPlugin = require('fastify-plugin');
const sqlite3 = require('sqlite3').verbose();
const { open } = require('sqlite');

async function dbConnector(fastify, options) {
  const db = await open({
    filename: './data/transcendence.db',
    driver: sqlite3.Database
  });
  
  // Create tables if they don't exist
  await db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      username TEXT UNIQUE NOT NULL,
      display_name TEXT,
      avatar TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    // ... other table definitions
  `);
  
  // Add database methods to Fastify instance
  fastify.decorate('db', {
    async all(sql, params = []) {
      return await db.all(sql, params);
    },
    async get(sql, params = []) {
      return await db.get(sql, params);
    },
    async run(sql, params = []) {
      return await db.run(sql, params);
    }
  });
}
```

This plugin:
- Establishes SQLite database connection
- Creates necessary tables if they don't exist
- Provides database query methods to the Fastify instance

# 3. API Routes Implementation

## A. Authentication Routes (routes/auth.js)
```javascript
export async function authRoutes(fastify, options) {
    // Register new user
    fastify.post('/register', {
        schema: {
            body: {
                type: 'object',
                required: ['username', 'email', 'password'],
                properties: {
                    username: { type: 'string', minLength: 3 },
                    email: { type: 'string', format: 'email' },
                    password: { type: 'string', minLength: 6 }
                }
            }
        }
    }, async (request, reply) => {
        // Registration logic
    });

    // Login endpoint
    fastify.post('/login', {
        schema: {
            body: {
                type: 'object',
                required: ['username', 'password'],
                properties: {
                    username: { type: 'string' },
                    password: { type: 'string' }
                }
            }
        }
    }, async (request, reply) => {
        // Login logic
    });

    // Get current user
    fastify.get('/me', {
        onRequest: [fastify.authenticate]
    }, async (request, reply) => {
        // Get user profile logic
    });
}
```

## B. Authentication Plugin (plugins/auth.js)
```javascript
import fp from 'fastify-plugin';

async function authPlugin(fastify, options) {
    fastify.decorate('authenticate', async function(request, reply) {
        try {
            await request.jwtVerify();
        } catch (err) {
            reply.code(401).send({ error: 'Unauthorized' });
        }
    });
}

export const auth = fp(authPlugin, {
    name: 'auth',
    dependencies: ['@fastify/jwt']
});
```

## C. Password Hashing (plugins/bcrypt.js)
```javascript
import fp from 'fastify-plugin';
import bcrypt from 'bcrypt';

async function bcryptPlugin(fastify, options) {
    fastify.decorate('bcrypt', {
        async hash(password) {
            const salt = await bcrypt.genSalt(10);
            return bcrypt.hash(password, salt);
        },
        async compare(password, hash) {
            return bcrypt.compare(password, hash);
        }
    });
}

export const bcryptHandler = fp(bcryptPlugin, {
    name: 'bcrypt'
});
```

# 4. Service Configuration

## A. Port Configuration
- Main Application (Backend + Frontend): http://localhost:4001

## B. Database Configuration
```javascript
const sqlite3 = require('sqlite3').verbose();
const { open } = require('sqlite');

const db = await open({
    filename: join(__dirname, '../db/transcendence.sqlite'),
    driver: sqlite3.Database
});

// Example query using SQLite
await db.run(`
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        email TEXT UNIQUE,
        password_hash TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
`);

// Example of a query with parameters
await db.run(`
    INSERT INTO users (username, email, password_hash)
    VALUES (?, ?, ?)
`, [username, email, hashedPassword]);

// Example of retrieving data
const user = await db.get(`
    SELECT * FROM users WHERE id = ?
`, userId);
```

# 5. Security Features

## A. JWT Authentication
- Secret key configuration in server setup
- Token generation on login/registration
- Token verification middleware

## B. Password Security
- Bcrypt hashing for passwords
- Salt rounds configuration
- Secure password comparison

## C. CORS Configuration
```javascript
await fastify.register(cors, {
    origin: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    credentials: true,
});
```

# 6. Database Schema

```sql
-- Users Table
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    display_name TEXT,
    email TEXT UNIQUE,
    password_hash TEXT NOT NULL,
    avatar_url TEXT,
    wins INTEGER DEFAULT 0,
    losses INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Games Table
CREATE TABLE IF NOT EXISTS games (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    player1_id INTEGER NOT NULL,
    player2_id INTEGER,
    player1_score INTEGER DEFAULT 0,
    player2_score INTEGER DEFAULT 0,
    game_type TEXT NOT NULL CHECK(game_type IN ('single', 'multi')),
    status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'active', 'completed')),
    winner_id INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (player1_id) REFERENCES users (id),
    FOREIGN KEY (player2_id) REFERENCES users (id),
    FOREIGN KEY (winner_id) REFERENCES users (id)
);

-- Tournaments Table
CREATE TABLE IF NOT EXISTS tournaments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    start_date TEXT,
    end_date TEXT,
    status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'active', 'completed')),
    winner_id INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (winner_id) REFERENCES users (id)
);

-- Tournament Participants Table
CREATE TABLE IF NOT EXISTS tournament_participants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tournament_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    status TEXT DEFAULT 'registered' CHECK(status IN ('registered', 'active', 'eliminated')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(tournament_id, user_id),
    FOREIGN KEY (tournament_id) REFERENCES tournaments (id),
    FOREIGN KEY (user_id) REFERENCES users (id)
);

-- Tournament Games Table
CREATE TABLE IF NOT EXISTS tournament_games (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tournament_id INTEGER NOT NULL,
    game_id INTEGER NOT NULL,
    round INTEGER NOT NULL,
    match_number INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(tournament_id, round, match_number),
    FOREIGN KEY (tournament_id) REFERENCES tournaments (id),
    FOREIGN KEY (game_id) REFERENCES games (id)
);
```

# 7. Testing and Maintenance

## A. API Testing
1. Browser-based testing interface (/tests/api-test.html)
   - Interactive UI for testing endpoints
   - Real-time response display
   - Easy to use for manual testing

2. Node.js test script (/tests/api-test.js)
   - Automated testing of all endpoints
   - Comprehensive test coverage
   - Console output for results

## B. Error Handling
```javascript
// Example of SQLite error handling
try {
    const result = await db.run(`
        INSERT INTO users (username, email)
        VALUES (?, ?)
    `, [username, email]);
} catch (error) {
    if (error.code === 'SQLITE_CONSTRAINT') {
        // Handle unique constraint violation
        reply.code(400).send({ error: 'Username or email already exists' });
    } else {
        // Handle other database errors
        fastify.log.error(error);
        reply.code(500).send({ error: 'Internal Server Error' });
    }
}
```

## C. Monitoring and Debugging
1. Logging
   - Request logging with Fastify's built-in logger
   - Error logging with stack traces
   - Performance monitoring using SQLite's EXPLAIN QUERY PLAN

2. Database Management
   - Regular SQLite database backups using `.backup` command
   - Data integrity checks with `PRAGMA integrity_check`
   - Performance optimization with proper indexing
   ```sql
   -- Example of adding indexes for performance
   CREATE INDEX IF NOT EXISTS idx_games_player1 ON games(player1_id);
   CREATE INDEX IF NOT EXISTS idx_games_player2 ON games(player2_id);
   CREATE INDEX IF NOT EXISTS idx_tournament_participants ON tournament_participants(tournament_id, user_id);
   ```

# Additional Resources

1. Fastify Documentation: https://www.fastify.io/docs/latest/
2. SQLite Documentation: https://www.sqlite.org/docs.html
3. Node.js Documentation: https://nodejs.org/en/docs/

# Notes

- Backend runs on port 4002
- JWT is used for authentication
- Passwords are hashed using bcrypt
- SQLite database is used for persistence
- All services are containerized using Docker
- Inter-service communication is handled through Docker network

# Testing Commands

```bash
# Test registration
curl -X POST http://localhost:4002/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "email": "test@example.com", "password": "password123"}'

# Test login
curl -X POST http://localhost:4002/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "password": "password123"}'

# Test protected endpoint
curl http://localhost:4002/api/auth/me \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"

# SQLite CLI commands for database inspection
sqlite3 ./data/transcendence.db << EOF
.tables
.schema users
SELECT COUNT(*) FROM users;
.quit
EOF
```

See docker-compose.yml for complete service configuration.